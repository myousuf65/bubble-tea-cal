package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"slices"
	"strconv"
	"strings"
	"time"

	"github.com/charmbracelet/bubbles/textarea"
	tea "github.com/charmbracelet/bubbletea"
)

type model struct {
	dates          map[string][]string
	activeDate     int
	activeMonth    string
	inputfield     textarea.Model
	showinputfield bool
	monthOrder     []string
}

type Change int

const (
	Decrease Change = 0
	Increase Change = 1
)

func getfileinfo(month string, day int) string {
	// user home directory
	home, err := os.UserHomeDir()
	if err != nil {
		panic(err)
	}

	// filename
	filename := strconv.Itoa(day) + ".txt"

	// full file path
	return filepath.Join(home, "journal", month, filename)
}

func checkMonthChange(allDaysInMonth []string, day int, change Change) bool {
	idx := slices.Index(allDaysInMonth, strconv.Itoa(day))

	changeMonth := false

	// increase month
	if change == Increase {
		if idx == len(allDaysInMonth)-1 || idx == -1 {
			changeMonth = true
		}
	}

	//decrease month
	if change == Decrease {
		if idx == 0 || idx == -1 {
			changeMonth = true
		}
	}

	log.Println("changeMonth : ", changeMonth, " idx: ", idx)

	return changeMonth
}

func InitialModel() model {

	m := make(map[string][]string)

	m["January"] = []string{"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
		"11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
		"21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31"}

	m["February"] = []string{"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
		"11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
		"21", "22", "23", "24", "25", "26", "27", "28"}

	m["March"] = []string{"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
		"11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
		"21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31"}

	m["April"] = []string{"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
		"11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
		"21", "22", "23", "24", "25", "26", "27", "28", "29", "30"}

	m["May"] = []string{"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
		"11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
		"21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31"}

	m["June"] = []string{"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
		"11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
		"21", "22", "23", "24", "25", "26", "27", "28", "29", "30"}

	m["July"] = []string{"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
		"11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
		"21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31"}

	m["August"] = []string{"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
		"11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
		"21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31"}

	m["September"] = []string{"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
		"11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
		"21", "22", "23", "24", "25", "26", "27", "28", "29", "30"}

	m["October"] = []string{"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
		"11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
		"21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31"}

	m["November"] = []string{"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
		"11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
		"21", "22", "23", "24", "25", "26", "27", "28", "29", "30"}

	m["December"] = []string{"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
		"11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
		"21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31"}

	// get todays date
	day := time.Now().Day()
	month := time.Now().Month()

	inputfield := textarea.New()
	inputfield.Focus()
	inputfield.Placeholder = "how's your day going"

	monthOrder := []string{"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}

	return model{
		dates:          m,
		activeDate:     day,
		activeMonth:    month.String(),
		inputfield:     inputfield,
		showinputfield: false,
		monthOrder:     monthOrder,
	}
}

func (m model) Init() tea.Cmd {
	return nil
}

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {

	// when text editor is open all keys should be directed there
	if m.showinputfield {
		var cmd tea.Cmd
		m.inputfield, cmd = m.inputfield.Update(msg)

		switch msg := msg.(type) {
		case tea.KeyMsg:
			switch msg.String() {
			case "esc":
				m.showinputfield = false

				// get input content
				content := m.inputfield.Value()

				// write to system
				filePath := getfileinfo(m.activeMonth, m.activeDate)

				os.MkdirAll(filepath.Dir(filePath), 0755)

				os.WriteFile(filePath, []byte(content), 0644)

				// reset text area
				m.inputfield.SetValue("")

				return m, nil
			}
		}

		return m, cmd
	}

	switch msg := msg.(type) {

	case tea.KeyMsg:
		key := msg.String()
		switch key {

		case "left":
			shouldChangeMonth := checkMonthChange(m.dates[m.activeMonth], m.activeDate, Decrease)

			if shouldChangeMonth && m.activeMonth != "January" {
				idx := slices.Index(m.monthOrder, m.activeMonth)
				m.activeMonth = m.monthOrder[idx-1]
				// date should be last day of month
				daysInMonth := m.dates[m.activeMonth]
				lastDay := daysInMonth[len(daysInMonth)-1]
				lastDayInt, _ := strconv.ParseInt(lastDay, 10, 64)
				m.activeDate = int(lastDayInt)

			} else {
				if m.activeDate == 1 && m.activeMonth == "January" {
					break
				} else {
					m.activeDate--
				}
			}
		case "right":

			shouldChangeMonth := checkMonthChange(m.dates[m.activeMonth], m.activeDate, Increase)

			if shouldChangeMonth && m.activeMonth != "December" {
				idx := slices.Index(m.monthOrder, m.activeMonth)
				m.activeMonth = m.monthOrder[idx+1]

				// date should be first day of month
				daysInMonth := m.dates[m.activeMonth]
				firstDay := daysInMonth[0]
				firstDayInt, _ := strconv.ParseInt(firstDay, 10, 64)
				m.activeDate = int(firstDayInt)

			} else {
				if m.activeDate == 31 && m.activeMonth == "December" {
					break
				} else {
					m.activeDate++
				}
			}

		case "up":

			nextValue := m.activeDate - 7
			shouldChangeMonth := false
			idx := slices.Index(m.dates[m.activeMonth], strconv.Itoa(nextValue))

			if idx == 0 || idx == -1 {
				shouldChangeMonth = true
			}

			log.Println("changeMonth : ", shouldChangeMonth, " idx: ", idx)

			if shouldChangeMonth && m.activeMonth != "January" {
				idx := slices.Index(m.monthOrder, m.activeMonth)
				m.activeMonth = m.monthOrder[idx-1]
				// date should be last day of month
				daysInMonth := m.dates[m.activeMonth]
				lastDay := daysInMonth[len(daysInMonth)-1]
				lastDayInt, _ := strconv.ParseInt(lastDay, 10, 64)
				m.activeDate = int(lastDayInt)

			} else if idx == -1 && m.activeMonth == "January" {
				break
			} else {
				m.activeDate = m.activeDate - 7
			}

		case "down":
			nextValue := m.activeDate + 7
			shouldChangeMonth := false
			idx := slices.Index(m.dates[m.activeMonth], strconv.Itoa(nextValue))

			if idx == 0 || idx == -1 {
				shouldChangeMonth = true
			}

			log.Println("changeMonth : ", shouldChangeMonth, " idx: ", idx)

			if shouldChangeMonth && m.activeMonth != "December" {
				idx := slices.Index(m.monthOrder, m.activeMonth)
				m.activeMonth = m.monthOrder[idx+1]

				// date should be first day of month
				daysInMonth := m.dates[m.activeMonth]
				firstDay := daysInMonth[0]
				firstDayInt, _ := strconv.ParseInt(firstDay, 10, 64)
				m.activeDate = int(firstDayInt)

			} else if idx == -1 && m.activeMonth == "December" {
				break
			} else {
				m.activeDate = m.activeDate + 7
			}

		case "a":

			// append previous entry
			filePath := getfileinfo(m.activeMonth, m.activeDate)
			content, err := os.ReadFile(filePath)

			if err != nil {
				// file does not exit
				log.Println("filepath not exist : " + filePath)
			} else {
				// file exists
				m.inputfield.SetValue(string(content))
			}

			m.showinputfield = true

		case "ctrl+c", "q":
			return m, tea.Quit
		}
	case tea.WindowSizeMsg:
		m.inputfield.SetHeight(msg.Height - 2)
		m.inputfield.SetWidth(msg.Width)
		log.Println("Height: " + strconv.Itoa(msg.Height) + "\tWidth: " + strconv.Itoa(msg.Width))

	}

	return m, nil

}

func (m model) View() string {

	// read file content
	filePath := getfileinfo(m.activeMonth, m.activeDate)
	content, err := os.ReadFile(filePath)

	if m.showinputfield {

		return fmt.Sprintf("%s\n\n ", m.inputfield.View())

	} else {

		var output strings.Builder
		output.WriteString("Day: " + strconv.Itoa(m.activeDate) + "\n")
		output.WriteString("Month: " + m.activeMonth + "\n")

		counter := 0
		// ------------current month ----------------
		for _, v := range m.dates[m.activeMonth] {
			s_v, _ := strconv.Atoi(v)

			if s_v == m.activeDate {
				output.WriteString(fmt.Sprintf("[%2s] ", v))
			} else {
				output.WriteString(fmt.Sprintf(" %2s  ", v))
			}

			counter++

			if counter == 7 {
				counter = 0
				output.WriteString("\n")
			}
		}

		//read file
		if err != nil {
			output.WriteString("\nno entry")
		} else {
			output.WriteString("\n\n" + string(content))
		}

		return output.String()
	}

}

func main() {

	file, err := os.OpenFile("app.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log.Fatal("Failed to open log file:", err)
	}
	defer file.Close()

	// Set the log output to the file
	log.SetOutput(file)

	log.Println("Application started at ", time.Now())

	// new bubbletea program
	p := tea.NewProgram(InitialModel())
	if _, err := p.Run(); err != nil {
		log.Printf("Alas, there's been an error: %v", err)
		os.Exit(1)
	}

}
